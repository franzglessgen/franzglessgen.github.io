{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This webpage centralizes the documentation of all my open source projects. </p>"},{"location":"#overview","title":"Overview","text":""},{"location":"#website-building","title":"Website building","text":"<p>The documentation is built on the basis of the Mkdoc git repository (link on top right of this page).  The github webpage hosts the markdown content and is built by calling the command: </p> <pre><code>mkdocs gh-deploy --config-file ../MkdocFolder/mkdocs.yml --remote-branch main\n</code></pre> <p>from the GitWebpage repository.</p>"},{"location":"about_me/","title":"About me","text":"<p>About me</p>"},{"location":"Hardware/Overview/","title":"Overview","text":"<p>About me</p>"},{"location":"Hardware/Calibrations/SCC/","title":"Calibration of CMS sensors","text":""},{"location":"Hardware/Calibrations/SCC/#method","title":"Method","text":""},{"location":"Hardware/Calibrations/SCC/#software","title":"Software","text":""},{"location":"Hardware/Calibrations/SCC/#CalibrationSensor.Classes.Helpers","title":"<code>Helpers</code>","text":""},{"location":"Hardware/Calibrations/SCC/#CalibrationSensor.Classes.Helpers.Helpers","title":"<code>Helpers</code>","text":""},{"location":"Hardware/Calibrations/SCC/#CalibrationSensor.Classes.Helpers.Helpers.multi_gaussian","title":"<code>multi_gaussian(x, *params)</code>","text":"<p>Three Gaussian peaks: params = [amp1, mu1, sigma1, amp2, mu2, sigma2, amp3, mu3, sigma3]</p> Source code in <code>CalibrationSensor/Classes/Helpers/Helpers.py</code> <pre><code>def multi_gaussian(x, *params):\n    \"\"\"Three Gaussian peaks: params = [amp1, mu1, sigma1, amp2, mu2, sigma2, amp3, mu3, sigma3]\"\"\"\n    assert len(params) == 9\n    g1 = params[0] * np.exp(-0.5 * ((x - params[1]) / params[2])**2)\n    g2 = params[3] * np.exp(-0.5 * ((x - params[4]) / params[5])**2)\n    g3 = params[6] * np.exp(-0.5 * ((x - params[7]) / params[8])**2)\n    return g1 + g2 + g3\n</code></pre>"},{"location":"Hardware/Calibrations/SCC/#CalibrationSensor.Classes.Helpers.Helpers.one_gaussian","title":"<code>one_gaussian(x, *params)</code>","text":"<p>Three Gaussian peaks: params = [amp1, mu1, sigma1, amp2, mu2, sigma2]</p> Source code in <code>CalibrationSensor/Classes/Helpers/Helpers.py</code> <pre><code>def one_gaussian(x, *params):\n    \"\"\"Three Gaussian peaks: params = [amp1, mu1, sigma1, amp2, mu2, sigma2]\"\"\"\n    assert len(params) == 3\n    g1 = params[0] * np.exp(-0.5 * ((x - params[1]) / params[2])**2)\n    return g1\n</code></pre>"},{"location":"Hardware/Calibrations/SCC/#CalibrationSensor.Classes.Helpers.Helpers.peak_finding","title":"<code>peak_finding(rough_counts, rough_bins)</code>","text":"<p>Look for approximate mean and sigma of gaussian peaks in a histogram</p> Source code in <code>CalibrationSensor/Classes/Helpers/Helpers.py</code> <pre><code>def peak_finding(rough_counts, rough_bins):\n\n    \"\"\"\n\n    Look for approximate mean and sigma of gaussian peaks in a histogram \n\n\n    \"\"\"\n\n\n    derivative = np.diff(rough_counts)\n\n\n    means = [] \n    sigmas = []\n    amplitudes = []\n\n    #Find local maxima:\n\n    #Number of steps before sign inversion\n    step_counter = 0 \n    sign_ref = 1\n\n\n    for i_d, d in enumerate(derivative):\n\n        #Goes up \n        if np.sign(d) == sign_ref:\n            step_counter+=1\n\n        #Goes down, means we found a peak\n        else:\n\n            position = rough_bins[i_d]\n\n            means.append(position)\n            sigmas.append(step_counter*(rough_bins[1] - rough_bins[0]))\n            amplitudes.append(rough_counts[i_d])\n            step_counter = 0\n            sign_ref *=-1 \n\n    means = np.array(means)\n    sigmas = np.array(sigmas)\n    amplitudes = np.array(amplitudes)\n\n    means = means[sigmas&gt;5*(rough_bins[1] - rough_bins[0])]\n    amplitudes = amplitudes[sigmas&gt;5*(rough_bins[1] - rough_bins[0])]\n    sigmas = sigmas[sigmas&gt;5*(rough_bins[1] - rough_bins[0])]\n\n\n    return means, sigmas, amplitudes\n</code></pre>"},{"location":"Hardware/Calibrations/SCC/#CalibrationSensor.Classes.Helpers.Helpers.two_gaussian","title":"<code>two_gaussian(x, *params)</code>","text":"<p>Three Gaussian peaks: params = [amp1, mu1, sigma1, amp2, mu2, sigma2]</p> Source code in <code>CalibrationSensor/Classes/Helpers/Helpers.py</code> <pre><code>def two_gaussian(x, *params):\n    \"\"\"Three Gaussian peaks: params = [amp1, mu1, sigma1, amp2, mu2, sigma2]\"\"\"\n    assert len(params) == 6\n    g1 = params[0] * np.exp(-0.5 * ((x - params[1]) / params[2])**2)\n    g2 = params[3] * np.exp(-0.5 * ((x - params[4]) / params[5])**2)\n    return g1 + g2\n</code></pre>"},{"location":"Hardware/Calibrations/SCC/#CalibrationSensor.Classes.Pixel","title":"<code>Pixel</code>","text":""},{"location":"Hardware/Calibrations/SCC/#CalibrationSensor.Classes.Pixel.Pixel","title":"<code>Pixel</code>","text":"<p>Class describing one sensor pixel. </p> <p>Attributes: </p> <p>Function:</p> Source code in <code>CalibrationSensor/Classes/Pixel.py</code> <pre><code>class Pixel:\n\n    \"\"\"\n\n    Class describing one sensor pixel. \n\n\n    Attributes: \n\n\n    Function: \n\n\n    \"\"\"\n\n    def __init__(self, col: int, row: int):\n\n        self.col = col\n        self.row = row\n        self.position = [0,0,0]\n\n        #Unordered ADC counts measured to calibrate\n        self.unordered_hits = []\n\n\n    def __repr__(self):\n        return (f\"Pixel(col= {self.col}, row = {self.row}\")\n</code></pre>"},{"location":"Hardware/Calibrations/SCC/#CalibrationSensor.Classes.Sensor","title":"<code>Sensor</code>","text":""},{"location":"Hardware/Calibrations/SCC/#CalibrationSensor.Classes.Sensor.Sensor","title":"<code>Sensor</code>","text":"<p>Class describing a sensor. </p> <p>Attributes: </p> <pre><code>Config_file: File containing a dictionary of meta data\n\nPlot path: path to plots\n\nOutput path: path to output\n</code></pre> <p>Function:</p> Source code in <code>CalibrationSensor/Classes/Sensor.py</code> <pre><code>class Sensor:\n\n    \"\"\"\n\n    Class describing a sensor. \n\n\n    Attributes: \n\n        Config_file: File containing a dictionary of meta data\n\n        Plot path: path to plots\n\n        Output path: path to output\n\n\n    Function: \n\n\n    \"\"\"\n\n\n    def __init__(self, config_file: str, output_path: str = \"Output/\", plot_path: str = \"Plots/\"):\n\n        self.config_file = config_file + \".json\"\n        self.load_config_from_json()\n\n        self.output_path = os.path.join(output_path, self.name)\n        self.plot_path = os.path.join(plot_path, self.name)\n\n        os.makedirs(self.output_path, exist_ok = True)\n        os.makedirs(self.plot_path, exist_ok = True)\n\n\n        self.peak_to_vcal_file = os.path.join(self.output_path, \"peak_to_vcal.json\")\n\n\n        self.ncol = 432\n        self.nrow = 336\n\n        #For each source, each pixel has an offset and a slope from the gain file\n        self.pixel_gain = {\n                            \"Sn\": np.zeros((self.ncol, self.nrow, 2)),\n                            \"Ag\": np.zeros((self.ncol, self.nrow, 2)),\n                            \"Mo\": np.zeros((self.ncol, self.nrow, 2)),\n                            \"Zn\": np.zeros((self.ncol, self.nrow, 2))\n\n                            }\n\n\n        #Gain calibrated Delta VCAL values registered during an Xray run\n        self.charge_hist = {\n                            \"Sn\" : [],\n                            \"Ag\" : [],\n                            \"Mo\" : [],\n                            \"Zn\" : []\n                            }\n\n        #KeV \n        self.energy = { \n                            \"Sn\" : [25.27,28.49],\n                            \"Ag\" : [22.16,24.94],\n                            \"Mo\" : [17.48, 19.61],\n                            \"Zn\" : [8.64, 9.57]\n                            }\n\n\n\n        #self.load_gain_from_root()\n        #self.load_hits_from_root(include_zero = False)\n        #self.fit_charge_hist()\n        self.compute_Q_calib()\n\n        #self.plot_negative_gain()\n        #self.plot_charge_hist()\n\n    def compute_Q_calib(self):\n\n        with open(self.peak_to_vcal_file, \"r\") as f:\n            peak_to_vcal_dict = json.load(f)\n\n        energies = []\n        vcal_and_error = []\n\n        for s, p_s in peak_to_vcal_dict.items():\n\n            for n_p in range(len(p_s)):\n\n                if n_p%2 == 0:\n                    energies.append(self.energy[s][n_p//2])\n                vcal_and_error.append(p_s[n_p])\n\n        energies = np.array(energies)\n        vcal = np.array(vcal_and_error)[::2]\n        error = np.array(vcal_and_error)[1::2]\n\n        print(vcal)\n        print(error)\n\n\n        y_data = vcal\n        x_data = energies\n        y_errors = error\n\n        # 3. Fit using curve_fit with error bars\n        popt, pcov = curve_fit(poly1, x_data, y_data, sigma=y_errors, absolute_sigma=True)\n\n        # Extract fitted parameters and uncertainties\n        a, b = popt\n        perr = np.sqrt(np.diag(pcov))\n\n        da, db = perr\n\n        print(f\"Fitted coefficients:\")\n        print(f\"a = {a:.3f} \u00b1 {perr[0]:.3f}\")\n        print(f\"b = {b:.3f} \u00b1 {perr[1]:.3f}\")\n\n\n        print(f\"Slope:\", 1/a) \n        print(f\"Offset:\", -b/a) \n\n        # 4. Plot data with error bars and fitted curve\n        x_fit = np.linspace(min(x_data), max(x_data), 500)\n        y_fit = poly1(x_fit, *popt)\n\n        fig, ax = plt.subplots()\n\n        ax.errorbar(x_data, y_data, yerr=y_errors, fmt='o', label='Data', capsize=3 ,color = \"black\")\n        ax.plot(x_fit, y_fit, label='Linear fit', color='red')\n        ax.set_title(r\"Charge calibration of a SCC\", fontsize = 15) \n        ax.set_xlabel(\"Xray energy [keV]\", fontsize = 12, loc = \"right\") \n        ax.set_ylabel(\"Pixel charge signal [a.u.]\", fontsize = 12, loc = \"top\")\n        ax.tick_params(axis = \"both\", labelsize = 12)\n        ax.legend()\n        ax.grid(True)\n\n        ax.text(\n                x=8,       \n                y= 600,   \n                s=f'Zn',\n                color=\"blue\",\n                fontsize=15\n            )\n\n        ax.text(\n                x=17,       \n                y= 1100,   \n                s=f'Mo',\n                color=\"blue\",\n                fontsize=15\n            )\n        ax.text(\n                x=22,       \n                y= 1400,   \n                s=f'Ag',\n                color=\"blue\",\n                fontsize=15\n            )\n        ax.text(\n                x=26,       \n                y= 1600,   \n                s=f'Sn',\n                color=\"blue\",\n                fontsize=15\n            )\n\n\n        plot_path = os.path.join(self.plot_path, f\"Q_calib.pdf\")\n        plt.savefig(plot_path) \n        plt.close() \n\n\n\n\n\n\n    def fit_charge_hist(self):\n\n        peak_to_vcal_dict = {} \n\n\n        for k_r, v_r in self.meta_data[\"Xray_runs\"].items():\n\n\n            mean = np.mean(self.charge_hist[v_r[\"source\"]])\n            std = np.std(self.charge_hist[v_r[\"source\"]])\n\n            print(mean, std)\n\n\n            start, stop, step = mean - 5*std, mean + 5*std, 1\n            mult = 10\n\n            rough_counts, rough_bins= np.histogram(self.charge_hist[v_r[\"source\"]], bins = np.arange(start, stop, mult*step))\n            rough_bins = 0.5*(rough_bins[1:] + rough_bins[:-1])\n\n            #Finds two peaks\n            #means, sigmas, amplitudes = peak_finding(rough_counts, rough_bins)\n            #result = find_peaks_from_arr(rough_counts, rough_bins, 5)\n            means, sigmas, amplitudes = find_peaks_from_arr(rough_counts, rough_bins, 5)\n\n            sigmas/=2.\n\n            print(\"means\", means)\n            print(\"sigmas\", sigmas)\n            print(\"amp\", amplitudes)\n\n            fig, ax = plt.subplots()\n\n            ax.hist(self.charge_hist[v_r[\"source\"]], bins = np.arange(start, stop, mult*step), histtype='stepfilled', color='lightgray', label='Histogram')\n            #ax.set_xlabel(r\"$\\Delta$VCAL\")\n            ax.set_xlabel(r\"Pixel charge signal [a.u]\")\n            ax.set_ylabel(\"Counts\")\n            ax.set_title(f\"Spectrum of {v_r[\"source\"]} X-ray source\")\n            #ax.legend()\n            ax.grid(True)\n\n            plt.show()\n\n\n            if \"LF_21\" in self.name:\n                means = np.array([1250, 1550])\n                sigmas = np.array([100, 200])\n                amplitudes = np.array([15000, 3000])\n\n\n\n            if v_r[\"two_peaks\"]:\n\n                popt, pcov, bins_to_fit = fit_two_peaks(means[-2:], sigmas[-2:], amplitudes[-2:], rough_counts, rough_bins) \n                x_fit = np.linspace(bins_to_fit[0], bins_to_fit[-1], 1000)\n                y_fit = two_gaussian(x_fit, *popt)\n\n                peak_to_vcal_dict[v_r[\"source\"]] = [popt[1],pcov[1][1], popt[4], pcov[4][4]]\n\n            #Single peak\n            else:\n\n                popt, pcov, bins_to_fit = fit_one_peak(means[-1:], sigmas[-1:], amplitudes[-1:], rough_counts, rough_bins) \n                x_fit = np.linspace(bins_to_fit[0], bins_to_fit[-1], 1000)\n                y_fit = one_gaussian(x_fit, *popt)\n\n                peak_to_vcal_dict[v_r[\"source\"]] = [popt[1], pcov[1][1]]\n\n\n\n\n            print(\"popt\", popt)\n            print(\"pcov\", [pcov[i][i]/popt[i] for i in range(len(popt))]) \n\n\n            fig, ax = plt.subplots()\n\n            ax.hist(self.charge_hist[v_r[\"source\"]], bins = np.arange(start, stop, mult*step), histtype='stepfilled', color='lightgray', label='Histogram')\n            ax.plot(x_fit, y_fit, 'r-', label='2-Gaussian Fit')\n            ax.set_xlabel(r\"Pixel charge signal [a.u]\")\n            ax.set_ylabel(\"Counts\")\n            ax.set_title(f\"Spectrum of {v_r[\"source\"]} X-ray source\")\n            ax.legend()\n            ax.grid(True)\n\n            plt.show()\n\n        #Dump to file\n        with open(self.peak_to_vcal_file, \"w\") as f:\n            json.dump(peak_to_vcal_dict, f)\n\n\n    def plot_charge_hist(self):\n\n        for k_r, v_r in self.meta_data[\"Xray_runs\"].items():\n\n\n            #Plot around relevant range\n            start, stop, step =  np.mean(self.charge_hist[v_r[\"source\"]]) - 4*np.std(self.charge_hist[v_r[\"source\"]]), np.mean(self.charge_hist[v_r[\"source\"]]) + 4*np.std(self.charge_hist[v_r[\"source\"]]),10\n\n\n            fig, ax = plt.subplots()\n\n            ax.hist(self.charge_hist[v_r[\"source\"]], bins = np.arange(start, stop, step), histtype='stepfilled', color='gray', label='Histogram')\n            ax.set_xlabel(r\"$\\Delta$VCAL\")\n            ax.set_ylabel(\"Counts\")\n            ax.set_title(f\"Gain corrected cluster charge for Xray source: {v_r['source']}\")\n            #ax.legend()\n            ax.grid(True)\n\n            plot_path = os.path.join(self.plot_path, f\"ToT_{v_r['source']}.pdf\")\n            plt.savefig(plot_path) \n            plt.close() \n\n\n\n    def plot_negative_gain(self):\n\n        \"\"\"\n\n        For debugging negative gain offsets\n\n        \"\"\"\n\n        for k_r, v_r in self.meta_data[\"Xray_runs\"].items():\n\n            #path to gain: list. list[0] : path, list[1] : hybrid, list[2]: chip\n\n            gain_file = ROOT.TFile.Open(v_r[\"path_to_gain\"][0])\n\n            path_to_dir = \"Detector/Board_0/OpticalGroup_0/Hybrid_\" + v_r[\"path_to_gain\"][1] +\"/Chip_\"+v_r[\"path_to_gain\"][2] \n            path_to_intercept = \"D_B(0)_O(0)_H(\" + v_r[\"path_to_gain\"][1] +\")_InterceptLowQ2D_Chip(\" + v_r[\"path_to_gain\"][2] + \")\"\n            path_to_slope = \"D_B(0)_O(0)_H(\" + v_r[\"path_to_gain\"][1] +\")_SlopeLowQ2D_Chip(\" + v_r[\"path_to_gain\"][2] + \")\"\n            path_to_map = \"D_B(0)_O(0)_H(\" + v_r[\"path_to_gain\"][1] +\")_GainMap_Chip(\" + v_r[\"path_to_gain\"][2] + \")\"\n\n            gain_intercept = gain_file.Get(path_to_dir).Get(path_to_intercept).GetPrimitive(path_to_intercept)\n            gain_slope = gain_file.Get(path_to_dir).Get(path_to_slope).GetPrimitive(path_to_slope)\n            gain_map = gain_file.Get(path_to_dir).Get(path_to_map).GetPrimitive(path_to_map)\n\n            nbins_x = gain_slope.GetNbinsX()\n            nbins_y = gain_slope.GetNbinsY()\n\n            for ix in range(1, nbins_x + 1):\n                for iy in range(1, nbins_y + 1):\n                    intercept = gain_intercept.GetBinContent(ix, iy)\n                    slope = gain_slope.GetBinContent(ix, iy)\n                    self.pixel_gain[v_r[\"source\"]][ix-1, iy-1] = np.array([intercept, slope])\n\n                    if intercept &gt; 0:\n\n                        pix_gain = [gain_map.GetBinContent(ix, iy, k) for k in range(gain_map.GetNbinsZ())] \n\n                        plt.plot(range(gain_map.GetNbinsZ()), pix_gain)\n\n            plt.show()\n\n\n\n    def load_gain_from_root(self):\n\n        \"\"\"\n\n        Loads ToT to VCAL function from gain scan, each run should have its gain scan\n\n        \"\"\"\n\n\n        for k_r, v_r in self.meta_data[\"Xray_runs\"].items():\n\n            #path to gain: list. list[0] : path, list[1] : hybrid, list[2]: chip\n\n            gain_file = ROOT.TFile.Open(v_r[\"path_to_gain\"][0])\n\n            path_to_dir = \"Detector/Board_0/OpticalGroup_0/Hybrid_\" + v_r[\"path_to_gain\"][1] +\"/Chip_\"+v_r[\"path_to_gain\"][2] \n            path_to_intercept = \"D_B(0)_O(0)_H(\" + v_r[\"path_to_gain\"][1] +\")_InterceptLowQ2D_Chip(\" + v_r[\"path_to_gain\"][2] + \")\"\n            path_to_slope = \"D_B(0)_O(0)_H(\" + v_r[\"path_to_gain\"][1] +\")_SlopeLowQ2D_Chip(\" + v_r[\"path_to_gain\"][2] + \")\"\n\n            gain_intercept = gain_file.Get(path_to_dir).Get(path_to_intercept).GetPrimitive(path_to_intercept)\n            gain_slope = gain_file.Get(path_to_dir).Get(path_to_slope).GetPrimitive(path_to_slope)\n\n            nbins_x = gain_slope.GetNbinsX()\n            nbins_y = gain_slope.GetNbinsY()\n\n            for ix in range(1, nbins_x + 1):\n                for iy in range(1, nbins_y + 1):\n                    intercept = gain_intercept.GetBinContent(ix, iy)\n                    slope = gain_slope.GetBinContent(ix, iy)\n                    self.pixel_gain[v_r[\"source\"]][ix-1, iy-1] = np.array([intercept, slope])\n\n            #TDirectory* dir = (TDirectory*)f1-&gt;Get(\"Detector/Board_0/OpticalGroup_0/Hybrid_0/Chip_0\");\n            #TCanvas* Canvas1D = (TCanvas*)dir-&gt;Get(\"D_B(0)_O(0)_H(0)_ToT1D_Chip(0)\");\n            #TH1F *ToT1D = (TH1F*)Canvas1D-&gt;GetPrimitive(\"D_B(0)_O(0)_H(0)_ToT1D_Chip(0)\");\n\n\n\n    def load_hits_from_root(self, include_zero = True):\n\n\n        \"\"\"\n\n        Remove hits around threshold for Qcalib using the argument include_zero = False\n\n        \"\"\"\n\n\n\n        for k_r, v_r in self.meta_data[\"Xray_runs\"].items():\n\n            for v_p in v_r[\"path_to_runs\"]:\n\n                path_to_file = os.path.join(v_r[\"path_to_data\"], v_p)\n                print(path_to_file)\n                hit_file = ROOT.TFile.Open(path_to_file)\n\n                chip_name = \"rd53b_\" + v_r[\"h_and_c_ID\"][0] + v_r[\"h_and_c_ID\"][1]\n\n                tree = hit_file.Get(\"ClusteringSpatial/\"+chip_name+\"/PixelHits\")\n\n                for entry in tree:\n                    pixels_per_cluster = entry.clusterNumPixels\n                    tot = entry.pixelToT\n                    col = entry.pixelX\n                    row = entry.pixelY\n\n                    current_pix = 0\n\n                    #Could load the cluster charge directly, but need pixel by pixel gain conversion\n                    for i_np, np in enumerate(pixels_per_cluster):\n\n                        VCAL = 0\n                        #p denotes the number of pixels in that cluster, i_p is the cluster index\n                        for p in range(np):\n\n                            pix_tot = tot[current_pix + p]\n                            pix_col = col[current_pix + p]\n                            pix_row = row[current_pix + p]\n\n\n                            if pix_tot == 0 and not include_zero:\n                                continue\n\n\n                            #VCAL = (ToT - b)/a\n\n                            if self.pixel_gain[v_r[\"source\"]][pix_col, pix_row, 1] == 0:\n                                continue\n\n                            increment =  (pix_tot - self.pixel_gain[v_r[\"source\"]][pix_col, pix_row, 0])/self.pixel_gain[v_r[\"source\"]][pix_col, pix_row, 1]\n\n                            if increment &lt; 0:\n                                #print(\"\\n\")\n                                #print(f\" Negative charge ? {pix_tot},{pix_col},{pix_row}\")\n                                #print(f\" intercept: {self.pixel_gain[v_r['source']][pix_col, pix_row, 0]} \")\n                                #print(f\" slope: {self.pixel_gain[v_r['source']][pix_col, pix_row, 1]} \")\n                                #print(f\" increment: {increment}\")\n                                #print(\"\\n\")\n\n                                continue\n\n                            VCAL += increment\n\n                        if VCAL &gt; 0:\n                            self.charge_hist[v_r[\"source\"]].append(VCAL)\n\n                        #shift to next cluster index \n                        current_pix += np\n\n\n    def load_config_from_json(self): \n\n        with open(self.config_file, \"r\", encoding=\"utf-8\") as f:\n            data: list[dict[str, Any]] = json.load(f)  # raw JSON as list of dicts\n\n            self.name = data[0][\"name\"]\n            self.meta_data = data[0]\n</code></pre>"},{"location":"Hardware/Calibrations/SCC/#CalibrationSensor.Classes.Sensor.Sensor.load_gain_from_root","title":"<code>load_gain_from_root()</code>","text":"<p>Loads ToT to VCAL function from gain scan, each run should have its gain scan</p> Source code in <code>CalibrationSensor/Classes/Sensor.py</code> <pre><code>def load_gain_from_root(self):\n\n    \"\"\"\n\n    Loads ToT to VCAL function from gain scan, each run should have its gain scan\n\n    \"\"\"\n\n\n    for k_r, v_r in self.meta_data[\"Xray_runs\"].items():\n\n        #path to gain: list. list[0] : path, list[1] : hybrid, list[2]: chip\n\n        gain_file = ROOT.TFile.Open(v_r[\"path_to_gain\"][0])\n\n        path_to_dir = \"Detector/Board_0/OpticalGroup_0/Hybrid_\" + v_r[\"path_to_gain\"][1] +\"/Chip_\"+v_r[\"path_to_gain\"][2] \n        path_to_intercept = \"D_B(0)_O(0)_H(\" + v_r[\"path_to_gain\"][1] +\")_InterceptLowQ2D_Chip(\" + v_r[\"path_to_gain\"][2] + \")\"\n        path_to_slope = \"D_B(0)_O(0)_H(\" + v_r[\"path_to_gain\"][1] +\")_SlopeLowQ2D_Chip(\" + v_r[\"path_to_gain\"][2] + \")\"\n\n        gain_intercept = gain_file.Get(path_to_dir).Get(path_to_intercept).GetPrimitive(path_to_intercept)\n        gain_slope = gain_file.Get(path_to_dir).Get(path_to_slope).GetPrimitive(path_to_slope)\n\n        nbins_x = gain_slope.GetNbinsX()\n        nbins_y = gain_slope.GetNbinsY()\n\n        for ix in range(1, nbins_x + 1):\n            for iy in range(1, nbins_y + 1):\n                intercept = gain_intercept.GetBinContent(ix, iy)\n                slope = gain_slope.GetBinContent(ix, iy)\n                self.pixel_gain[v_r[\"source\"]][ix-1, iy-1] = np.array([intercept, slope])\n</code></pre>"},{"location":"Hardware/Calibrations/SCC/#CalibrationSensor.Classes.Sensor.Sensor.load_hits_from_root","title":"<code>load_hits_from_root(include_zero=True)</code>","text":"<p>Remove hits around threshold for Qcalib using the argument include_zero = False</p> Source code in <code>CalibrationSensor/Classes/Sensor.py</code> <pre><code>def load_hits_from_root(self, include_zero = True):\n\n\n    \"\"\"\n\n    Remove hits around threshold for Qcalib using the argument include_zero = False\n\n    \"\"\"\n\n\n\n    for k_r, v_r in self.meta_data[\"Xray_runs\"].items():\n\n        for v_p in v_r[\"path_to_runs\"]:\n\n            path_to_file = os.path.join(v_r[\"path_to_data\"], v_p)\n            print(path_to_file)\n            hit_file = ROOT.TFile.Open(path_to_file)\n\n            chip_name = \"rd53b_\" + v_r[\"h_and_c_ID\"][0] + v_r[\"h_and_c_ID\"][1]\n\n            tree = hit_file.Get(\"ClusteringSpatial/\"+chip_name+\"/PixelHits\")\n\n            for entry in tree:\n                pixels_per_cluster = entry.clusterNumPixels\n                tot = entry.pixelToT\n                col = entry.pixelX\n                row = entry.pixelY\n\n                current_pix = 0\n\n                #Could load the cluster charge directly, but need pixel by pixel gain conversion\n                for i_np, np in enumerate(pixels_per_cluster):\n\n                    VCAL = 0\n                    #p denotes the number of pixels in that cluster, i_p is the cluster index\n                    for p in range(np):\n\n                        pix_tot = tot[current_pix + p]\n                        pix_col = col[current_pix + p]\n                        pix_row = row[current_pix + p]\n\n\n                        if pix_tot == 0 and not include_zero:\n                            continue\n\n\n                        #VCAL = (ToT - b)/a\n\n                        if self.pixel_gain[v_r[\"source\"]][pix_col, pix_row, 1] == 0:\n                            continue\n\n                        increment =  (pix_tot - self.pixel_gain[v_r[\"source\"]][pix_col, pix_row, 0])/self.pixel_gain[v_r[\"source\"]][pix_col, pix_row, 1]\n\n                        if increment &lt; 0:\n                            #print(\"\\n\")\n                            #print(f\" Negative charge ? {pix_tot},{pix_col},{pix_row}\")\n                            #print(f\" intercept: {self.pixel_gain[v_r['source']][pix_col, pix_row, 0]} \")\n                            #print(f\" slope: {self.pixel_gain[v_r['source']][pix_col, pix_row, 1]} \")\n                            #print(f\" increment: {increment}\")\n                            #print(\"\\n\")\n\n                            continue\n\n                        VCAL += increment\n\n                    if VCAL &gt; 0:\n                        self.charge_hist[v_r[\"source\"]].append(VCAL)\n\n                    #shift to next cluster index \n                    current_pix += np\n</code></pre>"},{"location":"Hardware/Calibrations/SCC/#CalibrationSensor.Classes.Sensor.Sensor.plot_negative_gain","title":"<code>plot_negative_gain()</code>","text":"<p>For debugging negative gain offsets</p> Source code in <code>CalibrationSensor/Classes/Sensor.py</code> <pre><code>def plot_negative_gain(self):\n\n    \"\"\"\n\n    For debugging negative gain offsets\n\n    \"\"\"\n\n    for k_r, v_r in self.meta_data[\"Xray_runs\"].items():\n\n        #path to gain: list. list[0] : path, list[1] : hybrid, list[2]: chip\n\n        gain_file = ROOT.TFile.Open(v_r[\"path_to_gain\"][0])\n\n        path_to_dir = \"Detector/Board_0/OpticalGroup_0/Hybrid_\" + v_r[\"path_to_gain\"][1] +\"/Chip_\"+v_r[\"path_to_gain\"][2] \n        path_to_intercept = \"D_B(0)_O(0)_H(\" + v_r[\"path_to_gain\"][1] +\")_InterceptLowQ2D_Chip(\" + v_r[\"path_to_gain\"][2] + \")\"\n        path_to_slope = \"D_B(0)_O(0)_H(\" + v_r[\"path_to_gain\"][1] +\")_SlopeLowQ2D_Chip(\" + v_r[\"path_to_gain\"][2] + \")\"\n        path_to_map = \"D_B(0)_O(0)_H(\" + v_r[\"path_to_gain\"][1] +\")_GainMap_Chip(\" + v_r[\"path_to_gain\"][2] + \")\"\n\n        gain_intercept = gain_file.Get(path_to_dir).Get(path_to_intercept).GetPrimitive(path_to_intercept)\n        gain_slope = gain_file.Get(path_to_dir).Get(path_to_slope).GetPrimitive(path_to_slope)\n        gain_map = gain_file.Get(path_to_dir).Get(path_to_map).GetPrimitive(path_to_map)\n\n        nbins_x = gain_slope.GetNbinsX()\n        nbins_y = gain_slope.GetNbinsY()\n\n        for ix in range(1, nbins_x + 1):\n            for iy in range(1, nbins_y + 1):\n                intercept = gain_intercept.GetBinContent(ix, iy)\n                slope = gain_slope.GetBinContent(ix, iy)\n                self.pixel_gain[v_r[\"source\"]][ix-1, iy-1] = np.array([intercept, slope])\n\n                if intercept &gt; 0:\n\n                    pix_gain = [gain_map.GetBinContent(ix, iy, k) for k in range(gain_map.GetNbinsZ())] \n\n                    plt.plot(range(gain_map.GetNbinsZ()), pix_gain)\n\n        plt.show()\n</code></pre>"},{"location":"Hardware/Calibrations/SCC/#CalibrationSensor.Classes.Source","title":"<code>Source</code>","text":""},{"location":"Hardware/Calibrations/SCC/#CalibrationSensor.Classes.Source.Source","title":"<code>Source</code>","text":"<p>Class describing an Xray metal source. </p> <p>Attributes: </p> <p>Function:</p> Source code in <code>CalibrationSensor/Classes/Source.py</code> <pre><code>class Source:\n\n    \"\"\"\n\n    Class describing an Xray metal source. \n\n\n    Attributes: \n\n\n    Function: \n\n\n    \"\"\"\n\n    def __init__(self, name: str):\n        self.name = name        \n</code></pre>"},{"location":"ProtonTherapy/Overview/","title":"Proton therapy","text":"<p>A couple of notes. </p>"},{"location":"ProtonTherapy/Theory/BasicPhysics/","title":"Basic physics","text":"<p>A couple of notes. </p>"},{"location":"ProtonTherapy/Theory/BasicPhysics/#scattering-power","title":"Scattering power","text":""},{"location":"Software/Boundary/","title":"Boundary identification","text":"<p>About me</p>"},{"location":"Software/FBP/","title":"Filtered backprojection","text":""},{"location":"Software/FBP/#generalities","title":"Generalities","text":"<p>You want to reconstruct a (2D) density \\(f(x,y)\\) based on line integrals of the form</p> \\[ \\int_L f(x,y) \\mathrm{d}l  = -\\ln \\frac{I}{I_0}\\] <p>One line integral at \\((\\theta, t)\\) gives </p> \\[ p(\\theta, t) = \\int_{-\\infty}^{+\\infty} \\int_{-\\infty}^{+\\infty} f(x,y) \\: \\delta(y\\cos(\\theta) - x\\sin(\\theta) - t) \\: \\mathrm{d}x \\mathrm{d}x\\] <p>You measure that function for discrete values of \\(\\theta\\) and t by measuring the ratio of intensities.</p> <p>This can be inverted and leads to the filtered backprojection:</p> \\[ f(x,y) = \\int_{0}^{2\\pi} p \\ast g_{\\infty} (\\theta, y\\cos \\theta - x\\sin \\theta\\:) \\: \\mathrm{d}\\theta \\] <p>where \\(\\ast\\) represents the convolution (over t) and \\(g_{\\infty}\\) is the ramp-filter distribution. </p> <p>After discretization, this yields</p> \\[f(x,y) = \\frac{2\\pi}{N_\\theta} \\sum_{n=0}^{N_{\\theta} -1} \\tilde{p}[n,k(x,y,\\theta)] \\] <p>where \\(\\tilde{p}\\) is the convolution between the measured attenuation and the ramp filter and \\(\\Delta \\theta = \\frac{2\\pi}{N_\\theta}\\) is the angular step of the rotation scan. </p>"},{"location":"Software/FBP/#parallel-beam-reconstruction","title":"Parallel beam reconstruction","text":"<p>The index \\(k\\) depends on the position to be reconstructed.  In the case of parallel beam reconstruction, the positions of the detector along \\(t\\) are </p> \\[t_k = (k + O_k + \\frac{1}{2})\\Delta t - t_{max} \\] <p>so that \\(k\\) indexes the position \\(k\\Delta t\\) and \\(\\Delta t = \\frac{2 t_{max}}{N_k}\\).</p> <p>For a given position \\((x,y)\\) on the grid to reconstruct, an interpolation is needed between the closest reconstructed points. </p> <p>For a given \\(n\\) (or \\(\\theta = n\\Delta \\theta\\)). For a parallel beam, the offset can be used to gather more info during scans at redundant angles. </p>"},{"location":"Software/FBP/#fan-beam-reconstruction","title":"Fan beam reconstruction","text":"<p>Single source rotating around the target. Fan angle \\(\\gamma\\). The projections are now a function of \\(\\gamma\\) and \\(\\beta\\). The position of the source is given by \\((-R\\cos(\\beta), -R\\sin(\\beta))\\). </p> \\[p(\\theta, t) \\rightarrow p(\\beta, \\gamma)\\] <p>Similarly to the previous case, the discretization goes: </p> \\[\\gamma_k = (k + O_k + \\frac{1}{2})\\Delta \\gamma - \\gamma_{max} \\] <p>with \\(\\Delta \\gamma = \\frac{2 \\gamma_{max}}{N_{\\gamma}}\\)</p> <p>and </p> \\[\\beta_j = j\\Delta \\beta \\] <p>with \\(\\Delta \\beta = \\frac{2 \\pi}{N_{\\beta}}\\)</p> <p>For a flat detector, the convolution needs to be modified. First, the sampled attenuation depends on \\(\\beta\\) and \\(a\\) where \\(a\\) is the distance along the surface of the detector. </p> \\[p(\\beta, \\gamma) = p^F(\\beta, R\\tan \\gamma)\\] <p>or </p> \\[p^F(\\beta, a) = p(\\beta, \\arctan \\frac{a}{R})\\] <p>The convolution requires a pre-factor: </p> \\[\\tilde{p}^F(\\beta, a) = \\left( p^F(\\beta, a) \\frac{R}{\\sqrt{R^2+a^2}} \\right) \\ast g_{\\infty}(a) \\] <p>And the backprojection requires a scaling as well</p> \\[ f(x,y) = \\int_{0}^{2\\pi} \\frac{R^2}{U(x,y,\\beta)^2} \\tilde{p}^F (\\: \\beta, a(x,y,\\beta) \\:)\\: \\mathrm{d}\\beta \\] <p>The detector position is given by</p> \\[a(x,y,\\beta) = R\\frac{-x\\sin \\beta + y\\cos \\beta }{R + x\\cos \\beta + y \\sin \\beta} \\] <p>and </p> \\[U(x,y,\\beta) = R + x \\cos \\beta + y \\sin \\beta \\]"},{"location":"Software/Overview/","title":"Overview","text":"<p>About me</p>"},{"location":"Teaching/PhiloPhysics/","title":"Philosophy of Physics: theories of spacetime","text":"<p>A couple of notes. </p>"},{"location":"VHbb/Home/","title":"VHbb analyses","text":"<p>The group is working on different analysis in the VH(bb) topology on Run2 and Run3 datasets. Here is a non-exhaustive contact list for the different sub-analyses.</p> <ul> <li>Run2 STXS analysis:  Alessandro Calandri, Krunal Gedia, Christina Reissel</li> <li>Run2 EFT analysis: Alessandro Calandri, Suman Chatterjee, Franz Glessgen, Vasilije Perovic</li> <li>Run3 analysis: in the future</li> </ul>"},{"location":"VHbb/UL/EFT/Intro/","title":"Introduction","text":"<p>This is an introduction</p>"},{"location":"VHbb/UL/EFT/fit/","title":"Fit model","text":""},{"location":"VHbb/UL/EFT/fit/#setup","title":"Setup","text":"<p>Follow these instructions:</p> <pre><code>export SCRAM_ARCH=slc7_amd64_gcc900\nscram project CMSSW CMSSW_11_3_4\ncd CMSSW_11_3_4/src\ncmsenv\ngit clone https://github.com/cms-analysis/HiggsAnalysis-CombinedLimit.git HiggsAnalysis/CombinedLimit\ncd HiggsAnalysis/CombinedLimit\ngit checkout v9.1.0\nscramv1 b clean; scramv1 b \ngit clone https://github.com/cms-analysis/CombineHarvester.git CombineHarvester\ncd CombineHarvester\ngit checkout v2.0.0\ngit clone https://github.com/franzglessgen/VHLegacyEFT.git VHLegacy\ncd VHLegacy\ngit checkout CH_v2\ncp model/EFTscaling*.py ../../HiggsAnalysis/CombinedLimit/python/\ncd ../..\nscram b \n</code></pre> <p>In order to implement the Wj1b ratio SF, the following files need to be copied to the Combine Harvester repository:</p> <pre><code>/work/fglessge/Combine/CMSSW_11_3_4/src/CombineHarvester/CombineTools/interface/CombineHarvester.h\n/work/fglessge/Combine/CMSSW_11_3_4/src/CombineHarvester/CombineTools/src/CombineHarvester_Creation.cc\n/work/fglessge/Combine/CMSSW_11_3_4/src/CombineHarvester/CombineTools/src/CombineHarvester_Datacards.cc\n</code></pre> <p>And that repo then needs to be recompiled.</p>"},{"location":"VHbb/UL/EFT/fit/#workflow","title":"Workflow","text":"<p>Shape location: /work/fglessge/CMSSW_10_1_0/src/CombineHarvester/VHLegacy/shapes/UL/BIT_resolved_boosted_NLO_Dphi/</p>"},{"location":"VHbb/UL/EFT/fit/#asimov-sensitivity","title":"Asimov sensitivity:","text":"<p>Workspace</p> <pre><code>python RunAll.py -comb_fit -years 2018,2017,2016,2016preVFP -outputdir BIT_resolved_boosted -iteration 1 -WC c0,c1,c2,c3,c6,c7\n</code></pre> <p>Scans</p> <pre><code>python RunAll.py -comb_fit -years 2018,2017,2016,2016preVFP -outputdir BIT_resolved_boosted -iteration 2 -WC c0,c1,c2,c3,c6,c7\n</code></pre> <p>Hadd</p> <pre><code>python RunAll.py -comb_fit -years 2018,2017,2016,2016preVFP -outputdir BIT_resolved_boosted -iteration 3 -WC c0,c1,c2,c3,c6,c7\n</code></pre> <p>Plot</p> <pre><code>python RunAll.py -comb_fit -years 2018,2017,2016,2016preVFP -outputdir BIT_resolved_boosted -iteration 4 -WC c0,c1,c2,c3,c6,c7\n</code></pre> <p>Split syst and stat : </p> <p>Do the first 3 iterations. Then redo iteration 2 and 3 by adding the command line argument \"-breakdown 1\", this creates the scans with frozen syst and hadds them. Finally, do iteration 4 with the same argument for plotting everything in the same graph.</p>"},{"location":"VHbb/UL/EFT/fit/#goodness-of-fit","title":"Goodness of fit:","text":"<pre><code>python RunAll.py -gof -years 2018 -outputdir BIT_resolved_boosted_mergeWjZjSF -iteration 1 -WC c6,c7 -skip_dc 1\n</code></pre> <p>And then iterations 2,3 and 4</p>"},{"location":"VHbb/UL/EFT/fit/#impact-plots","title":"Impact plots:","text":"<pre><code>python RunAll.py -impact -years 2018,2017,2016,2016preVFP -outputdir BIT_RB_split_udsgc_emu_TT_channel -iteration 1 -WC c0,c1,c2,c3,c6,c7\n</code></pre> <p>add skip_dc 0 if you want to recreate the WS. Can be ran on the WS of an asimov sensitivity scan.</p> <p>And then iterations 2,3 and 4</p>"},{"location":"VHbb/UL/EFT/fit/#pre-and-postfit","title":"Pre and postfit:","text":"<p>Workspace with reduced set of WC to save time</p> <pre><code>python RunAll.py -comb_prefit -years 2018,2017,2016preVFP,2016 -outputdir BIT_resolved_boosted_prefit -iteration 1 -WC c6,c7\n</code></pre> <p>Prefit : lasts around 10 to 20 hours</p> <pre><code>python RunAll.py -comb_prefit -years 2018,2017,2016preVFP,2016 -outputdir BIT_resolved_boosted_prefit -iteration 2 -WC c6,c7\n</code></pre> <p>Plot prefits: its quick</p> <pre><code>python RunAll.py -comb_prefit -years 2018,2017,2016preVFP,2016 -outputdir BIT_resolved_boosted_prefit -iteration 3 -WC c6,c7\n</code></pre> <p>Do full fit: 10 hours or so</p> <pre><code>python RunAll.py -comb_prefit -years 2018,2017,2016preVFP,2016 -outputdir BIT_resolved_boosted_prefit -iteration 4 -WC c6,c7\n</code></pre> <p>Do postfit : 10 to 20 hours</p> <pre><code>python RunAll.py -comb_prefit -years 2018,2017,2016preVFP,2016 -outputdir BIT_resolved_boosted_prefit -iteration 5 -WC c6,c7\n</code></pre> <p>Plotfit plots: quick</p> <pre><code>python RunAll.py -comb_prefit -years 2018,2017,2016preVFP,2016 -outputdir BIT_resolved_boosted_prefit -iteration 6 -WC c6,c7\n</code></pre>"},{"location":"VHbb/UL/EFT/fit/#combining-years","title":"Combining years:","text":""},{"location":"VHbb/UL/EFT/fit/#asimov-scans","title":"Asimov scans:","text":"<p>Same structure as before: the individual DC for each year have to be in the directories with the same name (BIT_resolved_boosted)</p> <pre><code>python RunAll.py -full_fit -years 2018,2017,2016preVFP,2016 -outputdir BIT_resolved_boosted -iteration 1 -WC c0,c1,c2,c3,c6,c7\n</code></pre> <p>and iteration 2/3/4</p>"},{"location":"VHbb/UL/EFT/fit/#2d-asimov-sensitivity","title":"2D Asimov sensitivity:","text":"<p>Run the comb_prefit_2D command, same as 1D. Start from the iteration 2 if you already produced the Asimov WS. This launches 8k jobs per WC pair and per year. </p> <p>For the full fit: first create the WS and DC and then</p> <pre><code>python RunAll.py -comb_fit_2D -years 2018 -outputdir BTV_BIT_resolved_boosted -iteration 2 -WC c0,c1,c2,c3,c6,c7 -full_fit_2D\n</code></pre>"},{"location":"VHbb/UL/EFT/lgbm/","title":"vhbbLightGBM","text":"<p>Workflow for training, evaluation and optimization of the Boosted Information Tree (BIT) as described here and there (ref)</p>"},{"location":"VHbb/UL/EFT/lgbm/#setup","title":"Setup","text":"<p>LightGBM can only be run in a python 3 environment. </p> <p>To source the conda environment on tier3, execute the following command:</p> <pre><code>PATH=/work/${USER}/miniconda3/bin:${PATH}\n</code></pre> <p>For details: </p> <pre><code>https://wiki.chipp.ch/twiki/bin/view/CmsTier3/HowToSetupYourAccount#local_Anaconda_Conda_installatio\n</code></pre>"},{"location":"VHbb/UL/EFT/lgbm/#root-compatibility","title":"ROOT compatibility","text":"<p>The training and optimization of the BIT does not require ROOT. However, for the eval step in Xbb the ROOT and python versions have to be compatible. Such a match between versions can be obtained by forging ROOT in a conda environment:</p> <p>Reference: https://iscinumpy.gitlab.io/post/root-conda/</p> <pre><code>conda create -n my_root_env root -c conda-forge\n</code></pre> <pre><code>conda activate my_root_env\n</code></pre> <pre><code>conda config --env --add channels conda-forge\n</code></pre> <p>You might need to add the extra packages like matplotlib, pandas, ... in the environment.</p> <p>This environment has a built-in pyroot3 version. </p> <p>Since you do not want to source the global tier3 CMSSW environment (it would overide your conda env), you need to run</p> <pre><code>export CMSSW_BASE={your_path}/CMSSW/\n</code></pre> <p>for setting the paths.</p> <p>Everytime you start a tier3 session, the following steps need to be taken:</p> <p>To get out of the default tier3 conda env</p> <pre><code>conda deactivate\n</code></pre> <pre><code>conda activate\n</code></pre> <p>Enter the pyroot3/py3 env</p> <pre><code>conda activate my_root_env\n</code></pre>"},{"location":"VHbb/UL/EFT/lgbm/#training","title":"Training","text":""},{"location":"VHbb/UL/EFT/lgbm/#export","title":"Export","text":"<p>Choose the features you need for the training in training.ini and make sure that the List_for_submitscript variable is set to the training region you want (resolved or boosted).</p> <pre><code>./submit.py -T Zll2018 -F cachetraining-BIT -J cachetraining --queue veryshort.q\n</code></pre> <p>Export the data as an h5 file</p> <pre><code>./submit.py -T Zll2018 -J export_h5 -i\n</code></pre>"},{"location":"VHbb/UL/EFT/lgbm/#setup_1","title":"Setup","text":"<p>Clone the repository and cd into it</p> <pre><code>git clone https://github.com/franzglessgen/vhbbLightGBM.git\n</code></pre> <p>Check your conda env by executing the training and saving it</p> <pre><code>python train.py -i ../dumps/DUMPNAME.h5 -name BITNAME_ -WC 1 -quad -train\n</code></pre> <p>This last command executes the training for a specified EFT component. The command line argument -WC defines the EFT index that is to be trained. The indexing is the same as in the reweighting card:</p> <pre><code>[0:'cHj1', \n 1:'cHj3', \n 2:'cHu', \n 3:'cHd', \n 4:'cHudRe', \n 5:'cHudIm', \n 6:'cHW', \n 7:'cHWtil', \n 8:'cHB', \n 9:'cHBtil', \n 10:'cHWB', \n 11:'cHWBtil', \n 12:'cHbox', \n 13:'cHDD', \n 14:'cbHRe', \n 15:'cbHIm']\n</code></pre> <p>Examples: -WC 1 -quad trains the quadratic component of cHj3. -WC 1,2 -quad trains the interaction term between cHj1 and cHu. -WC 1 (no -quad) trains the linear component of cHj3.</p> <p>The training also generates the result directories:</p> <ul> <li>trainings : saves the training arrays for this EFT component</li> <li>checkpoints : saves the BIT model for this EFT component</li> <li>plots</li> </ul>"},{"location":"VHbb/UL/EFT/lgbm/#merging","title":"Merging","text":"<p>In order to increase the statistical power of the training, the 4 years will be merged for training in each channel. A dedicated module dataMerger is used for the merging and to check that the distributions of features match across years. The command for merging 4 datasets that correspond to the exports of each year is the following:</p> <pre><code>python train.py -merger_input ../dumps/BIT_SRlowmedhigh_fullSet_Zll -merger_name BIT_SRlowmedhigh_fullSet_Zll -merge\n</code></pre> <p>For the command to work, the h5 files have to be named PREFIXYEAR, in this case:</p> <pre><code>BIT_SRlowmedhigh_fullSet_Zll2016.h5\n</code></pre> <p>for the 2016 dataset and similarly for the other years. The command loads the features for each year separately. The features as well as the weights can then be compared across years. </p>"},{"location":"VHbb/UL/EFT/lgbm/#training-and-plotting","title":"Training and plotting","text":"<p>The previous command loads the data from the h5 file, cleans the feature names and selects the features that are listed in the dictionary \"feature_dict\" in feature_config.py or feature_config_boost.py. Only the features listed in this dictionary with a key matching exactly the cleaned up name of the imported features will be considered. The dictionary also renames the features for more clarity.  The muons and electron features are then merged in a lepton category.</p> <p>The training parameters can be changed in the command line </p> <ul> <li>num_leaves</li> <li>max_depth</li> <li>min_data_in_leaf</li> <li>learning_rate</li> <li>max_bin (Light GBM binning of the features)</li> </ul> <p>If the -train argument is absent from the command line, the training will be loaded from a checkpoint (defined by the name used in the training with the -name argument).</p> <p>A few functions should be called to check the quality of the training:</p> <ul> <li>plot_features</li> <li>plot_weights: plots EFT weights used in training</li> <li>plot_score: plots output distribution for SIG and BG</li> <li>plot_feature_importance</li> <li>plot_all_profiled_features : plots the output score, profiled in the features to check the agreement between detector level quantities and joint quantities.</li> <li>plot_metrics : plots the loss function </li> </ul> <p>Additional function are available like plotting the BIT parameters or the correlation matrix of features, ...</p>"},{"location":"VHbb/UL/EFT/lgbm/#training-all-eft-components","title":"Training all EFT components","text":"<p>A simple script can be executed to perform the training for all EFT components. </p> <p>The command is </p> <pre><code>python RunTrainings.py -prefix Zll2018_BIT_ -WC 0,1,6,7 -train\n</code></pre> <p>The naming scheme of the h5 files (the Cuts) are hard-coded for boosted and resolved in the script RunTrainings.py.</p> <p>In this case the cuts are:</p> <pre><code>Cuts = [\"SRlowmedhigh_noDNNcut_allfeatures\", \"boosted_noDNNcut_allfeatures\"]\n</code></pre> <p>So the dump file is named:</p> <pre><code>prefix + cut\nZll2018_BIT_SRlowmedhigh_noDNNcut_allfeatures\n</code></pre> <p>This command then performs \\(2N + \\frac{N(N-1)}{2}\\) trainings, where N is the number of WC (defined by the indices).</p> <p>To obtain all plots related to the trainings do </p> <pre><code>python RunTrainings.py -prefix Zll2018_BIT_ -WC 0,1,6,7 -plot_training\n</code></pre> <p>The submission script actually runs the function gridsearch() which does a hyperparameter optimization on the fly and runs the training with the best parameters. The definition of the parameter grid is hard coded in \"grid search\". Because of the many trainings of this grid search, the resolved training might take a while (run on standard partition, should be done under 2 hours).</p> <p>Small issue with the training of the mixed component of chj1 and cHWtilde (c0 and c7).</p>"},{"location":"VHbb/UL/EFT/lgbm/#asimov-sensitivity-studies","title":"Asimov sensitivity studies","text":"<p>Once the individual trainings are done, they can be gathered for the Asimov studies.</p>"},{"location":"VHbb/UL/EFT/lgbm/#regressor-collection","title":"Regressor Collection","text":"<p>The Regressor collection loads BIT regressors of multiple WC at once. It can then be used to combine the shapes and perform LLH scans</p> <p>The syntax is similar to the training one. The WC indices can be specified. The regressor will then contain all EFT components corresponding to those. The name of the RegressorCollection has to match the name of the trainings to be loaded.</p> <p>For more flexibility, the BIT predictions and EFT weights of the different EFT components can be saved and simply loaded. LLH scans can be performed, the results of which can also be saved and loaded.</p>"},{"location":"VHbb/UL/EFT/lgbm/#loading","title":"Loading","text":"<p>Three functions can be called:</p> <ul> <li>read_arrays_from_training: combine the individual EFT components into a single file</li> <li>save_arrays: Drops the combined trainings into a h5 file</li> <li>read_arrays: Only function used after calling the 2 previous one. Only reads from the combined file. </li> </ul> <p>This command has to be called once before anything else.</p> <pre><code>python RunTrainings.py -prefix Zll2018_BIT_ -WC 0,1,6,7 -save_arrays\n</code></pre>"},{"location":"VHbb/UL/EFT/lgbm/#eft-scaling","title":"EFT scaling","text":"<p>Two different objects are needed for computing the optimal observables.</p>"},{"location":"VHbb/UL/EFT/lgbm/#eft-weight-scaling","title":"EFT weight scaling","text":"<p>The scaling of the EFT number of events (differential or inclusive) is controlled by the parameter \\(\\alpha\\) according to this formula:</p> <p>$$ N_{\\text{EFT}}(\\vec{\\alpha}) = S_0 + \\sum_i S_{1i} \\frac{\\alpha_i}{\\Lambda^2} +  \\sum_{j} S_{2j} \\frac{\\alpha_j^2}{\\Lambda^4} +  \\sum_{j,k} S_{3jk} \\frac{\\alpha_j \\alpha_k}{\\Lambda^4}  $$</p> <p>The function set_alphas stores the value of each EFT coefficient. The function set_scaling_alpha then computes the scaling for each EFT component according to the formula. After calling those, the function compute_EFT_weights stores the EFT scaling weights for all events at the considered WC point.</p>"},{"location":"VHbb/UL/EFT/lgbm/#likelihood-ratio-scaling","title":"Likelihood ratio scaling","text":"<p>The template shape also scales with the WC values according to the formula:</p> \\[R(x|\\theta, \\theta_0) = 1 + (\\theta - \\theta_0)_a R_a(x) + \\frac{1}{2}(\\theta - \\theta_0)_a(\\theta - \\theta_0)_bR_{ab}(x) \\] <p>where the indices \\(a\\) and \\(b\\) run over the WC. This second type of scaling is controlled by the parameter \\(\\theta\\)  and can be computed in a similar way to the \\(\\alpha\\) scaling.</p> <p>The \\(\\alpha\\) and \\(\\theta\\) scaling naming will be used throughout this documentation.</p>"},{"location":"VHbb/UL/EFT/lgbm/#workflow","title":"Workflow","text":"<p>The purpose of this analysis framework is to produce a 2D sigma matrix to choose the best 1D template shape for maximum sensitivity.</p>"},{"location":"VHbb/UL/EFT/lgbm/#checks","title":"Checks","text":"<p>You might need to produce a couple of preliminary plots to check the quality of the combined trainings.</p> <p>The script RunAll.py can be used to avoid lengthy command line arguments. It just needs the name of the trainings and the considered WC.</p>"},{"location":"VHbb/UL/EFT/lgbm/#features-and-score","title":"Features and score","text":"<p>The command:</p> <pre><code>python RunTrainings.py -prefix Zll2018_BIT_ -WC 0,1,6,7 -plot_template\n</code></pre> <p>will plot the features used in the training with the corresponding EFT effects. The EFT point is held in the dictionary WC_point_dict in scan_config. It will also plot the output shape at given \\(\\theta\\) and \\(\\alpha\\) points with a flat binning for the SM signal as well as EFT effects. </p>"},{"location":"VHbb/UL/EFT/lgbm/#optimal-1d-scan","title":"Optimal 1D scan","text":"<p>To check for the consistency of the training, running 1D optimal frozen scans for each WC can be done</p> <pre><code>python RunTrainings.py -prefix Zll2018_BIT_ -WC 0,1,6,7 -run_scans_1D\n</code></pre> <p>The range of the template points that will be scanned are defined in config/scan_config:</p> <ul> <li>theta_ranges : controls the range of the template shape points to try</li> <li>alpha_ranges : LLH range, be sure it holds the 2 sigma boundary on each WC.</li> </ul> <p>The command runs both the optimal 1D scan as well as one LLH scan for each choice of the template shape (number of \\(\\theta\\) points).</p> <p>The script CollectShapes.py also allows to run checks locally before/after submissions. Ex: - plot_sigma_variations : plots the 1D sigma scan</p>"},{"location":"VHbb/UL/EFT/lgbm/#2d-llh-scans","title":"2D LLH scans","text":"<p>The two following commands </p> <pre><code>python RunTrainings.py -prefix Zll2018_BIT_ -WC 0,1,6,7 -run_scans_2D_opt\n</code></pre> <pre><code>python RunTrainings.py -prefix Zll2018_BIT_ -WC 0,1,6,7 -run_scans_2D\n</code></pre> <p>will run all 2D scans needed for the selection of the template shape. For the optimal ones it will produce a 2D LLH scan for each pair of WC (the template shape is optimal at each point in the 2D LLH scan).</p> <p>For the non-optimal ones, it will go through the whole 2D range of \\(\\theta\\) points : \\(\\theta_i \\times \\theta_j\\) for each pair of WC.  For each grid point it will produce a 2D LLH scan by changing the template shape each time.</p> <p>This command launches a very large number of jobs:</p> \\[ \\frac{1}{2}N_{cat}N(N-1).Card[\\theta_i \\times \\theta_j] \\]"},{"location":"VHbb/UL/EFT/lgbm/#merge-scans","title":"Merge scans","text":"<p>Collect the results, fit the 1 and 2 sigma contours and produce a 2D sigma matrix for each WC pair:</p> <pre><code>python RunTrainings.py -prefix Zll2018_BIT_ -WC 0,1,6,7 -sigma\n</code></pre>"},{"location":"VHbb/UL/EFT/lgbm/#merge-matrices","title":"Merge matrices","text":"<p>Merge matrices and choose best template. This runs locally, should be short. Except for the minimization of the contraints on the \\(N\\times N\\) matrix of 2D matrices.</p> <pre><code>python RunTrainings.py -prefix Zll2018_BIT_ -WC 0,1,6,7 -merge_sigma\n</code></pre> <p>It also plots the chosen template shape.</p>"},{"location":"VHbb/UL/EFT/lgbm/#profiled-llh-scans","title":"Profiled LLH scans","text":"<p>Produce profiled LLH scans to check the robustness of the chosen template shape Do a stat only floating LLH scan for all WC: the 2 sigma intervals shouldn't blow up.</p> <pre><code>python RunTrainings.py -prefix Zll2018_BIT_ -WC 0,1,6,7 -profiler\n</code></pre>"},{"location":"VHbb/UL/EFT/lgbm/#evaluation","title":"Evaluation","text":""},{"location":"VHbb/UL/EFT/reweighting/","title":"Reweighting procedure","text":"<p>This Section provides a full description of all Xbb-specific computation and application of reweighting weights to MC samples to account for mismodellings and hardware deficiencies.</p>"},{"location":"VHbb/UL/EFT/reweighting/#list-of-reweighting-weights","title":"List of reweighting weights","text":"<p>The following weights are applied:</p> <ul> <li>Btag weights to account for the mismodelling in the lower than loose region of the btag score</li> <li>DeltaRbb weights to account for the MADGRAPH mismodelling at \\(\\Delta\\text{Rbb} &lt;1\\)</li> <li>\\(P_{t}(jj)\\) weights to account for the mismodelling observed at low \\(P_{t}(jj)\\) values</li> </ul>"},{"location":"VHbb/UL/EFT/reweighting/#impacted-cr","title":"Impacted CR","text":"<p>Here is a table summarizing the regions in which weights are applied. It is to be read from top to bottom, weights are computed for processes in pure regions before being applied in less pure regions to extract the weights for other processes there.</p> Channel Process Btag dRbb Ptjj DY LF LF + HF HF + LF Zll WJ \\(\\times\\) \\(\\times\\) \\(\\times\\) ZJ \\(\\times\\) \\(\\times\\) \\(\\times\\) ttbar \\(\\times\\) \\(\\times\\) \\(\\times\\) DY \\(\\times\\) LF + HF LF + HF Wlv WJ \\(\\times\\) LF +HF \\(\\times\\) ZJ \\(\\times\\) \\(\\times\\) \\(\\times\\) ttbar ttbar (if mis) \\(\\times\\) \\(\\times\\) DY \\(\\times\\) LF + HF \\(\\times\\) Zvv WJ \\(\\times\\) LF + HF \\(\\times\\) ZJ \\(\\times\\) LF + HF \\(\\times\\) ttbar \\(\\times\\) \\(\\times\\) \\(\\times\\)"},{"location":"VHbb/UL/EFT/reweighting/#2-lepton-treatment","title":"2-lepton treatment","text":"<p>In the 2-lepton channel, all three types of weights are applied. </p>"},{"location":"VHbb/UL/EFT/reweighting/#btag-weights","title":"Btag weights","text":"<p>The btag weights are applied in the ZLF only since it is the only region containing events satisfying btag &lt; loose. They are computed by taking the data/MC ratio in the 2D grid (btag1, btag0). The Xbb steps for computing them are as follows:</p> <ul> <li> <p>Run the plots for the following variable with a fine binning  <code>plotDef:DeepJet_2D_finebinning_2lep</code>  This is a finely binned 2D grid covering the lower than loose btag scores. The option : draw = RATIO has to be present as well as the option channelTag_for_reweight in Plot_general. A 2D plot with such options will enter the corresponding code in NewStackMaker. It will then remove all contributions that are not Z + light jets events from the data histogram and compute the ratio to MC Z + light.</p> </li> <li> <p>The previous plot is good for visualization, but the binning that was chosen for reweighting is the following: </p> </li> </ul> <pre><code>[-0.01, 0.01, 0.02333, LTL] \n</code></pre> <p>were LTL is the lower than loose boundary for the given year. The same binning is used for the low/med and high regions to have a good control on shape effects.</p> <ul> <li>The 2D plot with the previous binning has to be ran in 6 ZLF regions: Zee_low, Zee_med and Zee_high, Zmm_low, ...  </li> </ul> <pre><code>plotDef:DeepJet_2D_low_2lep\n</code></pre> <ul> <li>The logs will contain the central values and uncertainties of the btag weights.</li> <li>Copy those into the script: myutils/BTagWeightsDYltlooseWP (for 2lep) for each year and split in region</li> <li>Run the module Compute_btag_2D_2lep, it will fill branches with the btag weights (only for DY in Zll)</li> </ul> <pre><code>./submit.py -T Zll2018 -F weight_btag2D -J sysnew --addCollections Sys.Compute_btag_2D_2lep --input WEIGHTin --output WEIGHTout --queue veryshort.q\n</code></pre> <ul> <li>Apply the weights, rerun the caching/plotting to check closure in the btag weight 2D map and to check differences in other plots.</li> </ul>"},{"location":"VHbb/UL/EFT/reweighting/#deltarbb-weights","title":"deltaRbb weights","text":"<ul> <li> <p>Those weights have to be applied after the btag ones. The Xbb steps for computing them are as follows:</p> </li> <li> <p>Runplots on deltaRbb with FSR recovery in ZLF (inclusive in pT, split in ee and mm). The plot def is the following </p> </li> </ul> <pre><code>plotDef:deltaRbbWithFSR_UL_LF\n</code></pre> <ul> <li> <p>The binning is defined by 3 bins from 0.4 to 1.0.</p> </li> <li> <p>IMPORTANT: the overall normalization may be different between ZLF and ZHF. To compute it, the plot has an additional bin between 1.0 and 1.3. This bin has a large number of events and is in an orthogonal region to the low dijet pt region (see next section). The weights obtained in the &lt;1.0 bins have to be divided by the weight computed in the bin [1.0, 1.3]. This way, the overall normalization does not play a role. </p> </li> <li> <p>Get the central values and uncertainties for those 2 regions by adding the options draw = RATIO and draw_region = LF in the plot def</p> </li> <li>Copy the SF and uncertainties to the DeltaRbb module</li> </ul> <pre><code>NLORbblt1Weights_2lep.py\n</code></pre> <ul> <li>Run the module to apply those (in ZLF and ZHF)</li> </ul> <pre><code>./submit.py -T Zll2018 -F weight_deltaRbb -J sysnew --addCollections Sys.Compute_deltaRbb_2lep --input WEIGHTin --output WEIGHTout --queue veryshort.q\n</code></pre>"},{"location":"VHbb/UL/EFT/reweighting/#ptjj-weights","title":"Ptjj weights","text":"<p>After having applied the btag and deltaRbb weights, the pt(jj) has to be corrected at low values. The weights are computed in the ZLF region and then applied to ZLF and ZHF. The steps are as follows:</p> <ul> <li>Runplot for the variable in the ZLF region </li> </ul> <pre><code>Hpt_weights_low \n</code></pre> <p>with the binning:</p> <pre><code>[0,25.0,50.0,75.0,100.0,200.0]\n</code></pre> <p>The correction is differential in pt and in lepton flavour (6 regions). Do not forget the options draw = RATIO and draw_region = LF in the plot def.</p> <ul> <li> <p>Copy the central values and uncertainties in the module PtjjWeights.py</p> </li> <li> <p>Divide the central values by the overall normalization given by the last bin [100.0, 200.0]. IMPORTANT: only correct the dijet pt up to 100 GeV. The last bin is for computing this normalization so that it does not bias the application to HF.</p> </li> <li> <p>Run the module </p> </li> </ul> <pre><code>./submit.py -T Zll2018 -F Add_ptjj_weights -J sysnew --addCollections Sys.Compute_ptjj_2lep --input WEIGHT_pt_jj_in --output WEIGHT_pt_jj_out -i\n</code></pre>"},{"location":"VHbb/UL/EFT/reweighting/#1-lepton-treatment","title":"1-lepton treatment","text":"<p>The 1-lepton channel is more invested since both the DY and the WJ contributions need to be corrected.</p>"},{"location":"VHbb/UL/EFT/reweighting/#weights-for-dy-samples","title":"Weights for DY samples","text":"<p>The scale factors for DY samples have been computed in the regions of high Z+Jets purity. The same SF can thus be used in the Wlv channel. The btag weights were computed for both jets in the lower than loose region so this does not apply. Thus, only the ptjj and deltaRbb weights for DY samples are applied. Copy the weights from the previous modules into the PtjjAndDeltaRbbWeights module and use the following command:</p> <pre><code>./submit.py -T Wlv2018 -F Ptjj_deltaRbb_DY -J sysnew --addCollections Sys.Compute_ptjj_and_deltaRbb_DY_1lep --input DY_weights_in --output DY_weights_out --queue veryshort.q\n</code></pre> <p>You then need to recache the plots in the TT region for the next step</p>"},{"location":"VHbb/UL/EFT/reweighting/#btag-weights_1","title":"Btag weights","text":"<p>Btag weights still need to be applied in the WLF and TT CR because there is no btag score cut on the  subleading jet in these regions. Thus, the events in the lower than loose region need to be reweighted to account for the btag mismodelling there.  We chose to not apply the weights in the WLF region because the two bins to be corrected represent the largest part of the events. An overall normalization cannot be computed precisely because of this. Only apply the btag weight to TT</p> <p>To compute the SF, do the same in for the 2 lepton channel meaning:   - define a binning in btag score in the lower than loose region for the subleading jet  - add the options draw = RATIO and draw_region = TT   - run the plots in the TT region (split in e/m and pt med/high)  - copy the SF to the BTagWeights_WJ_TT_ltlooseWP script  - Divide them by the overall normalization  - run the script using the following command</p> <pre><code>./submit.py -T Wlv2018 -F btag_WJ_TT -J sysnew --addCollections Sys.Compute_btag_weights_WJ_TT_1lep --input Btag_weights_WJ_TT_in --output Btag_weights_WJ_TT_out --queue veryshort.q\n</code></pre> <ul> <li>For 2018, the ttbar was well modelled so these weights were skipped altogether. </li> <li>Fill the dictionary of WLF jets with 1.0 so that those weights are not used.</li> </ul> <p>You then need to recache the plots in the region WLF for the next step</p>"},{"location":"VHbb/UL/EFT/reweighting/#deltarbb-weights_1","title":"DeltaRbb weights","text":"<p>The deltaRbb weights are computed in WLF and applied to W+Jets in WLF and WHF. The steps are the same as for the btag weights, but the variable to be plotted is deltaRbb (split in 3 bins) in the region [0,1]. Do not forget to get the overall normalization in the region [1.0,5.0] and divide the central values and uncertainties by it.</p> <p>Copy the optained weights in NLORbblt1Weights_1lep (inclusive in pt and split in Wenu and Wmunu) and run the command to apply them:</p> <pre><code>./submit.py -T Wlv2018 -F deltaRbb_WJ -J sysnew --addCollections Sys.Compute_deltaRbb_weights_1lep --input DeltaRbb_weights_WJ_in --output DeltaRbb_weights_WJ_out --queue veryshort.q\n</code></pre> <p>You then need to recache the plots in the WLF for the next step</p>"},{"location":"VHbb/UL/EFT/reweighting/#0-lepton-treatment","title":"0-lepton treatment","text":"<p>For the 0-lep channel, simply apply the DeltaRbb weights. They are applied inclusively for all V+Jets samples (split in pt bins med/high).  There is an important difference in this channel because the overall MC normalization can be off. This overall normalization will be different in LF and HF so that the following steps need to be taken:</p> <ul> <li>Runplots on the deltaRbb variable with an additional bin from 1.0 to 4.0</li> <li>This last bin will give you the overall normalization of the LF</li> <li>The weights need to be divided by the overall normalization in LF but NOT in HF</li> <li>The relevant argument is self.overallNormalization_LF </li> </ul> <p>Then, run the corresponding module (NLORbblt1Weights_0lep) like that:</p> <pre><code>./submit.py -T Zvv2018 -F deltaRbb_VJets-v3 -J sysnew --addCollections Sys.Compute_deltaRbb_weights_0lep --input DeltaRbb_weights_in --output DeltaRbb_weights_out --queue veryshort.q\n</code></pre>"},{"location":"VHbb/UL/EFT/reweighting/#summary","title":"Summary","text":"<p>Here are all the steps for the full reweighting of a single year:</p>"},{"location":"VHbb/UL/EFT/systematics/","title":"Computation of systematics","text":""},{"location":"VHbb/UL/EFT/systematics/#2-lep-treatment","title":"2-lep treatment","text":"<p>Compute full set of MET syst. This replaces the syst branches MET_T1_pt/phi using the T1Smear uncertainties by propagating them through the METXY correction. </p> <pre><code>./submit.py -T Zll2018 -F Full_MET_syst -J sysnew --addCollections Sys.full_syst_MET --input Full_MET_syst_in --output Full_MET_syst_out -S ZHJet_HToBB_ZToLL_M-125_TuneCP5_SMEFTsim_topU3l_13TeV-madgraphMLM-pythia8 -i\n</code></pre> <p>Compute full set of syst for the Vboson (only in 0 and 1 lep since its influenced by MET)</p> <p>Computes full set of syst for corrected mSD:</p> <pre><code>./submit.py -T Zll2018 -F Full_mSD_syst -J sysnew --addCollections Sys.full_syst_mSD --input Full_msD_syst_in --output Full_msD_syst_out -S ZHJet_HToBB_ZToLL_M-125_TuneCP5_SMEFTsim_topU3l_13TeV-madgraphMLM-pythia8 -i\n</code></pre> <p>Then, compute the reduced set for Jet pt, mass Fatjet pt, mass and MET</p> <pre><code>./submit.py -T Zll2018 -F Reduced_syst -J sysnew --addCollections Sys.regroup_syst --input Reduced_syst_in --output Reduced_syst_out -S ZHJet_HToBB_ZToLL_M-125_TuneCP5_SMEFTsim_topU3l_13TeV-madgraphMLM-pythia8 --force -i\n</code></pre> <p>Then, recompute Higgs Candidate systematics. This will replace the erroneous syst with the correct, updated ones.</p> <pre><code>./submit.py -T Zll2018 -F Higgs_syst -J sysnew --addCollections Sys.HiggsReco --input Higgs_syst_in --output Higgs_syst_out -S ZHJet_HToBB_ZToLL_M-125_TuneCP5_SMEFTsim_topU3l_13TeV-madgraphMLM-pythia8 -i\n</code></pre> <p>Recompute kinfit stat: </p> <pre><code>./submit.py -T Zll2018 -F Kinfit_syst -J sysnew --addCollections KinematicFit.fitter --input Kinfit_syst_in --output Kinfit_syst_out -S ZHJet_HToBB_ZToLL_M-125_TuneCP5_SMEFTsim_topU3l_13TeV-madgraphMLM-pythia8 -i\n</code></pre> <p>Then, recompute EFT obs:</p> <pre><code>./submit.py -T Zll2018 -F EFT_obs_syst_2 -J sysnew --addCollections Sys.AddEFTobs --input EFT_obs_syst_2_in --output EFT_obs_syst_2_out -S ZHJet_HToBB_ZToLL_M-125_TuneCP5_SMEFTsim_topU3l_13TeV-madgraphMLM-pythia8 --force -i\n</code></pre> <p>Rerun is boosted for the systematics</p>"}]}